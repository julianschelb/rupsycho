# ===========================================================================
#                              Parser Utils
# ===========================================================================
# Utility functions for implementing parsers used for cleaning and
# validating model outputs.


from difflib import SequenceMatcher
import re
import json
import warnings
import os


def check_span(text: str, filter_dictionary: dict[str, list[str]], span: tuple[int, int] = None, ratio: float = None) -> dict[str, int]:
    """
    Checks the occurrence of specified answers in the text within a defined span or ratio of the text length.

    Args:
        text (str): The input text to search.
        filter_dictionary (dict[str, list[str]]): A dictionary where the keys are categories and the values are lists of answers to check for in the text.
        span (tuple[int, int], optional): A tuple defining the start and end positions within the text to search. Defaults to None.
        ratio (float, optional): A ratio (0.0 to 1.0) of the text length to define the portion of the text to search. Negative ratios start from the end of the text. Defaults to None.

    Returns:
        dict[str, bool]: A dictionary where keys are the categories and values are booleans indicating if any answers were found in the specified span or ratio of the text.
    """
    if span:
        start, end = span
        sub_text = text[start:end]
    elif ratio:
        length = int(len(text) * abs(ratio))
        if ratio > 0:
            sub_text = text[:length]
        else:
            sub_text = text[-length:]
    else:
        sub_text = text

    result = {}
    for category, answers in filter_dictionary.items():
        result[category] = any(answer.lower() in sub_text.lower()
                               for answer in answers)

    return result


def prompt_cleaner(prompt, completion, fast: bool = True, similarity_threshold: float = 0.5, junk: str = None) -> dict[str, float, float]:
    """Cleans the model's output by trimming repeated sections of the input prompt.

    This function identifies and removes any part of the model's output (`completion`) that closely matches a section of the input `prompt`. The goal is to clean the output by eliminating unnecessary repetitions.

    Args:
        prompt (str): The original input prompt.
        completion (str): The output generated by the model.
        fast (bool): If True, uses a faster but less precise similarity calculation, tends to result with higher scores. Defaults to True.
        similarity_threshold (float): The similarity threshold (between 0 and 1) above which a repeated section is considered for removal. Defaults to 0.5.
        junk (str): A string containing characters to be ignored when considering matches (e.g., whitespace, punctuation). Defaults to " \t\n.,;:!?".

    Returns:
        dict: A dictionary with two keys:
            - 'completion' (str): The cleaned output with any repeated prompt sections removed.
            - 'similarity_score' (float): The similarity score between the prompt and the completion.
            - 'similarity_threshold' (float): The similarity threshold that was set for the processing.
    """

    if similarity_threshold <= 0:
        warnings.warn(
            "similarity_threshold must be greater than 0. Setting it to 0.001.")
        similarity_threshold = 0.001

    def mini_preprocess(txt): return txt.lower().strip()
    prompt, completion = mini_preprocess(
        prompt), mini_preprocess(completion)

    if junk:
        def isjunk(x):
            return x in junk
        matcher = SequenceMatcher(isjunk=isjunk, a=prompt, b=completion)
    else:
        matcher = SequenceMatcher(a=prompt, b=completion)

    if fast:
        ratio = matcher.real_quick_ratio()
    else:
        ratio = matcher.ratio()

    if matcher.find_longest_match().size > 0:
        if ratio >= similarity_threshold:
            smallest_block = min((block for block in matcher.get_matching_blocks(
            )), key=lambda x: x.size, default=None)
            completion = completion[smallest_block.a: smallest_block.b].strip(
            )

    return {'completion': completion, 'similarity_score': round(ratio, 3), 'similarity_threshold': similarity_threshold}


def process_completion(text, pattern_name=None, regex_dict_path=None, user_input_pattern=None):
    """
    Process the text using a specified regex pattern.

    Args:
        text (str): The input text to be processed.
        pattern_name (str, optional): The name of the pattern to use from the regex dictionary ("numeric_alpha", "alpha_alpha", "numeric_numeric").
        regex_dict_path (str, optional): The path to a JSON file containing regex patterns.
        user_input_pattern (str, optional): A regex pattern provided by the user.

    Returns:
        list: A list of matched groups from the text based on the specified pattern.

    Raises:
        ValueError: If none of pattern_name, regex_dict_path, or user_input_pattern are provided.
        ValueError: If the specified pattern_name does not exist in the default or provided regex dictionary.
    """
    # Default patterns
    default_patterns = {
        'numeric_alpha': r'(\d+)([.,])(.+)',
        'alpha_alpha': r'([A-Za-z]+)([.,])(.+)',
        'numeric_numeric': r'(\d+)([.,])(\s*\d+)'
    }

    if user_input_pattern:
        pattern = user_input_pattern
        match = re.findall(pattern, text)
        if isinstance(match, list) and len(match) == 1:
            return match

    elif regex_dict_path:
        with open(regex_dict_path, 'r') as file:
            patterns = json.load(file)
            if pattern_name in patterns:
                pattern = patterns[pattern_name]
            else:
                raise ValueError(
                    f"Pattern name '{pattern_name}' not found in the provided regex dictionary.")

    elif pattern_name:
        if pattern_name in default_patterns:
            pattern = default_patterns[pattern_name]
        else:
            raise ValueError(
                f"Pattern name '{pattern_name}' not found in the default regex dictionary.")

    else:
        raise ValueError(
            "You must provide either pattern_name, regex_dict_path, or user_input_pattern.")

    return [item.strip() for match in re.findall(pattern, text) for item in match]


def check_multiple_choice_answers(text: str, possible_answers: list[str]) -> dict:
    """
    Checks for the presence of possible multiple-choice answers in the given text.
    It counts occurrences of parts of each answer as valid detections.

    Args:
        text (str): The input text to search within.
        possible_answers (list[str]): A list of possible answer strings to check for.

    Returns:
        dict: A dictionary where keys are the possible answers and values are the count of detections in the text.
    """

    text = text.lower()

    answer_counts = {answer: 0 for answer in possible_answers}

    split_pattern = r'(\d+|[a-zA-Z]+|[^a-zA-Z0-9\s])'

    for answer in possible_answers:
        normalized_answer = answer.lower()
        components = [component.strip() for component in re.findall(
            split_pattern, normalized_answer) if component.strip()]
        for component in components:
            match_pattern = fr"\b{re.escape(component)}\b"
            matches = re.findall(match_pattern, text)
            answer_counts[answer] += len(matches)
    return dict(answer_counts)


def split_on_symbols(text: str) -> list[str]:
    """
    Splits the input text based on numbers, special characters, and symbols.

    Args:
        text (str): The input string to split.

    Returns:
        list[str]: A list of non-empty components split by numbers, special characters, and symbols.
    """
    # Regex pattern to split on numbers, special characters, and symbols
    pattern = r'[\W_]+|\d+'

    # Split the text and filter out any empty components
    components = [component for component in re.split(
        pattern, text) if component]

    return components


def json_loader(path: str) -> dict:
    """
    Load a JSON file from the given path and return its contents as a dictionary.

    Args:
        path (str): Path to the JSON file.

    Returns:
        dict: Dictionary containing the JSON data.
    """
    with open(path, 'r', encoding='utf-8') as file:
        data = json.load(file)
    return data


def json_saver(data: dict, name: str = 'output', path: str = '') -> None:
    """
    Save a dictionary as a JSON file at the specified path and file name.
    If no path is provided, saves to the current directory.
    Prints the full path upon successful save.

    Args:
        data (dict): Dictionary to save as JSON.
        name (str, optional): Name of the file to save. Defaults to 'output'.
        path (str, optional): Directory path where the file will be saved. Defaults to the current directory.

    Returns:
        None
    """
    # Use current directory if no path is provided
    if not path:
        path = os.getcwd()
    if not name.endswith('.json'):
        full_path = os.path.join(path, f"{name}.json")
    else:
        full_path = os.path.join(path, f"{name}")
    with open(full_path, 'w', encoding='utf-8') as file:
        json.dump(data, file, indent=4)
    print(f"File saved successfully at: {full_path}")
